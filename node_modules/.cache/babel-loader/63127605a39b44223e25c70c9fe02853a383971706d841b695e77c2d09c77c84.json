{"ast":null,"code":"require(\"core-js/modules/es.typed-array.to-reversed.js\");\nrequire(\"core-js/modules/es.typed-array.to-sorted.js\");\nrequire(\"core-js/modules/es.typed-array.with.js\");\nrequire(\"core-js/modules/web.url-search-params.delete.js\");\nrequire(\"core-js/modules/web.url-search-params.has.js\");\nrequire(\"core-js/modules/web.url-search-params.size.js\");\nrequire(\"core-js/modules/es.array.push.js\");\n/*!\r\n * \r\n * js-audio-recorder - js audio recorder plugin\r\n * \r\n * @version v1.0.7\r\n * @homepage https://github.com/2fps/recorder\r\n * @author 2fps <echoweb@126.com> (https://www.zhuyuntao.cn)\r\n * @license MIT\r\n *         \r\n */\n!function (t, e) {\n  \"object\" == typeof exports && \"object\" == typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define([], e) : \"object\" == typeof exports ? exports.Recorder = e() : t.Recorder = e();\n}(this, function () {\n  return function (t) {\n    var e = {};\n    function n(i) {\n      if (e[i]) return e[i].exports;\n      var o = e[i] = {\n        i: i,\n        l: !1,\n        exports: {}\n      };\n      return t[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;\n    }\n    return n.m = t, n.c = e, n.d = function (t, e, i) {\n      n.o(t, e) || Object.defineProperty(t, e, {\n        enumerable: !0,\n        get: i\n      });\n    }, n.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, n.t = function (t, e) {\n      if (1 & e && (t = n(t)), 8 & e) return t;\n      if (4 & e && \"object\" == typeof t && t && t.__esModule) return t;\n      var i = Object.create(null);\n      if (n.r(i), Object.defineProperty(i, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & e && \"string\" != typeof t) for (var o in t) n.d(i, o, function (e) {\n        return t[e];\n      }.bind(null, o));\n      return i;\n    }, n.n = function (t) {\n      var e = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return n.d(e, \"a\", e), e;\n    }, n.o = function (t, e) {\n      return Object.prototype.hasOwnProperty.call(t, e);\n    }, n.p = \"\", n(n.s = 1);\n  }([function (t, e, n) {\n    \"use strict\";\n\n    function i(t, e, n) {\n      for (var i = 0; i < n.length; i++) t.setUint8(e + i, n.charCodeAt(i));\n    }\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.compress = function (t, e, n) {\n      for (var i = e / n, o = Math.max(i, 1), r = t.left, a = t.right, s = Math.floor((r.length + a.length) / i), u = new Float32Array(s), c = 0, l = 0; c < s;) {\n        var f = Math.floor(l);\n        u[c] = r[f], c++, a.length && (u[c] = a[f], c++), l += o;\n      }\n      return u;\n    }, e.encodePCM = function (t, e, n) {\n      void 0 === n && (n = !0);\n      var i = 0,\n        o = t.length * (e / 8),\n        r = new ArrayBuffer(o),\n        a = new DataView(r);\n      if (8 === e) for (var s = 0; s < t.length; s++, i++) {\n        var u = (c = Math.max(-1, Math.min(1, t[s]))) < 0 ? 128 * c : 127 * c;\n        u = +u + 128, a.setInt8(i, u);\n      } else for (s = 0; s < t.length; s++, i += 2) {\n        var c = Math.max(-1, Math.min(1, t[s]));\n        a.setInt16(i, c < 0 ? 32768 * c : 32767 * c, n);\n      }\n      return a;\n    }, e.encodeWAV = function (t, e, n, o, r, a) {\n      void 0 === a && (a = !0);\n      var s = n > e ? e : n,\n        u = r,\n        c = new ArrayBuffer(44 + t.byteLength),\n        l = new DataView(c),\n        f = o,\n        p = 0;\n      i(l, p, \"RIFF\"), p += 4, l.setUint32(p, 36 + t.byteLength, a), i(l, p += 4, \"WAVE\"), i(l, p += 4, \"fmt \"), p += 4, l.setUint32(p, 16, a), p += 4, l.setUint16(p, 1, a), p += 2, l.setUint16(p, f, a), p += 2, l.setUint32(p, s, a), p += 4, l.setUint32(p, f * s * (u / 8), a), p += 4, l.setUint16(p, f * (u / 8), a), p += 2, l.setUint16(p, u, a), i(l, p += 2, \"data\"), p += 4, l.setUint32(p, t.byteLength, a), p += 4;\n      for (var d = 0; d < t.byteLength;) l.setUint8(p, t.getUint8(d)), p++, d++;\n      return l;\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    var i,\n      o = this && this.__extends || (i = function (t, e) {\n        return (i = Object.setPrototypeOf || {\n          __proto__: []\n        } instanceof Array && function (t, e) {\n          t.__proto__ = e;\n        } || function (t, e) {\n          for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);\n        })(t, e);\n      }, function (t, e) {\n        function n() {\n          this.constructor = t;\n        }\n        i(t, e), t.prototype = null === e ? Object.create(e) : (n.prototype = e.prototype, new n());\n      });\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var r = n(2),\n      a = n(0),\n      s = n(3),\n      u = function (t) {\n        function e(e) {\n          void 0 === e && (e = {});\n          var n = t.call(this, e) || this;\n          return n.isrecording = !1, n.ispause = !1, n.isplaying = !1, n;\n        }\n        return o(e, t), e.prototype.setOption = function (t) {\n          void 0 === t && (t = {}), this.setNewOption(t);\n        }, e.prototype.start = function () {\n          return this.isrecording ? Promise.reject() : (this.isrecording = !0, this.startRecord());\n        }, e.prototype.pause = function () {\n          this.isrecording && !this.ispause && (this.ispause = !0, this.pauseRecord());\n        }, e.prototype.resume = function () {\n          this.isrecording && this.ispause && (this.ispause = !1, this.resumeRecord());\n        }, e.prototype.stop = function () {\n          this.isrecording && (this.isrecording = !1, this.ispause = !1, this.stopRecord());\n        }, e.prototype.play = function () {\n          this.stop(), this.isplaying = !0, this.onplay && this.onplay(), s.default.addPlayEnd(this.onplayend);\n          var t = this.getWAV();\n          t.byteLength > 44 && s.default.play(t.buffer);\n        }, e.prototype.getPlayTime = function () {\n          return s.default.getPlayTime();\n        }, e.prototype.pausePlay = function () {\n          !this.isrecording && this.isplaying && (this.isplaying = !1, this.onpauseplay && this.onpauseplay(), s.default.pausePlay());\n        }, e.prototype.resumePlay = function () {\n          this.isrecording || this.isplaying || (this.isplaying = !0, this.onresumeplay && this.onresumeplay(), s.default.resumePlay());\n        }, e.prototype.stopPlay = function () {\n          this.isrecording || (this.isplaying = !1, this.onstopplay && this.onstopplay(), s.default.stopPlay());\n        }, e.prototype.destroy = function () {\n          return s.default.destroyPlay(), this.destroyRecord();\n        }, e.prototype.getRecordAnalyseData = function () {\n          return this.getAnalyseData();\n        }, e.prototype.getPlayAnalyseData = function () {\n          return s.default.getAnalyseData();\n        }, e.prototype.getPCM = function () {\n          this.stop();\n          var t = this.getData();\n          return t = a.compress(t, this.inputSampleRate, this.outputSampleRate), a.encodePCM(t, this.oututSampleBits, this.littleEdian);\n        }, e.prototype.getPCMBlob = function () {\n          return new Blob([this.getPCM()]);\n        }, e.prototype.downloadPCM = function (t) {\n          void 0 === t && (t = \"recorder\");\n          var e = this.getPCMBlob();\n          r.downloadPCM(e, t);\n        }, e.prototype.getWAV = function () {\n          var t = this.getPCM();\n          return a.encodeWAV(t, this.inputSampleRate, this.outputSampleRate, this.config.numChannels, this.oututSampleBits, this.littleEdian);\n        }, e.prototype.getWAVBlob = function () {\n          return new Blob([this.getWAV()], {\n            type: \"audio/wav\"\n          });\n        }, e.prototype.downloadWAV = function (t) {\n          void 0 === t && (t = \"recorder\");\n          var e = this.getWAVBlob();\n          r.downloadWAV(e, t);\n        }, e.prototype.download = function (t, e, n) {\n          r.download(t, e, n);\n        }, e.prototype.getChannelData = function () {\n          var t = this.getPCM(),\n            e = t.byteLength,\n            n = this.littleEdian,\n            i = {\n              left: null,\n              right: null\n            };\n          if (2 === this.config.numChannels) {\n            var o = new DataView(new ArrayBuffer(e / 2)),\n              r = new DataView(new ArrayBuffer(e / 2));\n            if (16 === this.config.sampleBits) for (var a = 0; a < e / 2; a += 2) o.setInt16(a, t.getInt16(2 * a, n), n), r.setInt16(a, t.getInt16(2 * a + 2, n), n);else for (a = 0; a < e / 2; a += 2) o.setInt8(a, t.getInt8(2 * a)), r.setInt8(a, t.getInt8(2 * a + 1));\n            i.left = o, i.right = r;\n          } else i.left = t;\n          return i;\n        }, e;\n      }(n(5).default);\n    e.default = u;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    function i(t, e, n) {\n      var i = document.createElement(\"a\");\n      i.href = window.URL.createObjectURL(t), i.download = e + \".\" + n, i.click();\n    }\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.downloadWAV = function (t, e) {\n      void 0 === e && (e = \"recorder\"), i(t, e, \"wav\");\n    }, e.downloadPCM = function (t, e) {\n      void 0 === e && (e = \"recorder\"), i(t, e, \"pcm\");\n    }, e.download = function (t, e, n) {\n      return i(t, e, n);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var i = n(4),\n      o = null,\n      r = 0,\n      a = 0,\n      s = null,\n      u = null,\n      c = null,\n      l = !1,\n      f = 0,\n      p = function () {};\n    function d() {\n      return l = !1, s.decodeAudioData(c.slice(0), function (t) {\n        (o = s.createBufferSource()).onended = function () {\n          l || (f = s.currentTime - a + r, p());\n        }, o.buffer = t, o.connect(u), u.connect(s.destination), o.start(0, r), a = s.currentTime;\n      }, function (t) {\n        i.throwError(t);\n      });\n    }\n    function h() {\n      o && (o.stop(), o = null);\n    }\n    var y = function () {\n      function t() {}\n      return t.play = function (t) {\n        return s || (s = new (window.AudioContext || window.webkitAudioContext)(), (u = s.createAnalyser()).fftSize = 2048), this.stopPlay(), c = t, f = 0, d();\n      }, t.pausePlay = function () {\n        h(), r += s.currentTime - a, l = !0;\n      }, t.resumePlay = function () {\n        return d();\n      }, t.stopPlay = function () {\n        r = 0, c = null, h();\n      }, t.destroyPlay = function () {\n        this.stopPlay();\n      }, t.getAnalyseData = function () {\n        var t = new Uint8Array(u.frequencyBinCount);\n        return u.getByteTimeDomainData(t), t;\n      }, t.addPlayEnd = function (t) {\n        void 0 === t && (t = function () {}), p = t;\n      }, t.getPlayTime = function () {\n        var t = l ? r : s.currentTime - a + r;\n        return f || t;\n      }, t;\n    }();\n    e.default = y;\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    }), e.throwError = function (t) {\n      throw new Error(t);\n    };\n  }, function (t, e, n) {\n    \"use strict\";\n\n    Object.defineProperty(e, \"__esModule\", {\n      value: !0\n    });\n    var i = n(0),\n      o = function () {\n        function t(e) {\n          void 0 === e && (e = {}), this.size = 0, this.lBuffer = [], this.rBuffer = [], this.tempPCM = [], this.inputSampleBits = 16, this.fileSize = 0, this.duration = 0, this.needRecord = !0;\n          var n,\n            i = new (window.AudioContext || window.webkitAudioContext)();\n          this.inputSampleRate = i.sampleRate, this.setNewOption(e), this.littleEdian = (n = new ArrayBuffer(2), new DataView(n).setInt16(0, 256, !0), 256 === new Int16Array(n)[0]), t.initUserMedia();\n        }\n        return t.prototype.setNewOption = function (t) {\n          void 0 === t && (t = {}), this.config = {\n            sampleBits: ~[8, 16].indexOf(t.sampleBits) ? t.sampleBits : 16,\n            sampleRate: ~[8e3, 11025, 16e3, 22050, 24e3, 44100, 48e3].indexOf(t.sampleRate) ? t.sampleRate : this.inputSampleRate,\n            numChannels: ~[1, 2].indexOf(t.numChannels) ? t.numChannels : 1\n          }, this.outputSampleRate = this.config.sampleRate, this.oututSampleBits = this.config.sampleBits;\n        }, t.prototype.startRecord = function () {\n          var t = this;\n          return this.context && this.destroyRecord(), this.initRecorder(), navigator.mediaDevices.getUserMedia({\n            audio: !0\n          }).then(function (e) {\n            t.audioInput = t.context.createMediaStreamSource(e), t.stream = e;\n          }).then(function () {\n            t.audioInput.connect(t.analyser), t.analyser.connect(t.recorder), t.recorder.connect(t.context.destination);\n          });\n        }, t.prototype.pauseRecord = function () {\n          this.needRecord = !1;\n        }, t.prototype.resumeRecord = function () {\n          this.needRecord = !0;\n        }, t.prototype.stopRecord = function () {\n          this.audioInput && this.audioInput.disconnect(), this.source && this.source.stop(), this.recorder.disconnect(), this.analyser.disconnect(), this.needRecord = !0;\n        }, t.prototype.destroyRecord = function () {\n          return this.clearRecordStatus(), this.stopStream(), this.closeAudioContext();\n        }, t.prototype.getAnalyseData = function () {\n          var t = new Uint8Array(this.analyser.frequencyBinCount);\n          return this.analyser.getByteTimeDomainData(t), t;\n        }, t.prototype.getData = function () {\n          return this.flat();\n        }, t.prototype.clearRecordStatus = function () {\n          this.lBuffer.length = 0, this.rBuffer.length = 0, this.size = 0, this.fileSize = 0, this.PCM = null, this.audioInput = null, this.duration = 0;\n        }, t.prototype.flat = function () {\n          var t = null,\n            e = new Float32Array(0);\n          1 === this.config.numChannels ? t = new Float32Array(this.size) : (t = new Float32Array(this.size / 2), e = new Float32Array(this.size / 2));\n          for (var n = 0, i = 0; i < this.lBuffer.length; i++) t.set(this.lBuffer[i], n), n += this.lBuffer[i].length;\n          n = 0;\n          for (i = 0; i < this.rBuffer.length; i++) e.set(this.rBuffer[i], n), n += this.rBuffer[i].length;\n          return {\n            left: t,\n            right: e\n          };\n        }, t.prototype.initRecorder = function () {\n          var t = this;\n          this.clearRecordStatus(), this.context = new (window.AudioContext || window.webkitAudioContext)(), this.analyser = this.context.createAnalyser(), this.analyser.fftSize = 2048;\n          var e = this.context.createScriptProcessor || this.context.createJavaScriptNode;\n          this.recorder = e.apply(this.context, [4096, this.config.numChannels, this.config.numChannels]), this.recorder.onaudioprocess = function (e) {\n            if (t.needRecord) {\n              var n,\n                i = e.inputBuffer.getChannelData(0),\n                o = null;\n              t.lBuffer.push(new Float32Array(i)), t.size += i.length, 2 === t.config.numChannels && (o = e.inputBuffer.getChannelData(1), t.rBuffer.push(new Float32Array(o)), t.size += o.length), t.fileSize = Math.floor(t.size / Math.max(t.inputSampleRate / t.outputSampleRate, 1)) * (t.oututSampleBits / 8), n = 100 * Math.max.apply(Math, i), t.duration += 4096 / t.inputSampleRate, t.onprocess && t.onprocess(t.duration), t.onprogress && t.onprogress({\n                duration: t.duration,\n                fileSize: t.fileSize,\n                vol: n\n              });\n            }\n          };\n        }, t.prototype.stopStream = function () {\n          this.stream && this.stream.getTracks && (this.stream.getTracks().forEach(function (t) {\n            return t.stop();\n          }), this.stream = null);\n        }, t.prototype.closeAudioContext = function () {\n          return this.context && this.context.close && \"closed\" !== this.context.state ? this.context.close() : new Promise(function (t) {\n            t();\n          });\n        }, t.initUserMedia = function () {\n          void 0 === navigator.mediaDevices && (navigator.mediaDevices = {}), void 0 === navigator.mediaDevices.getUserMedia && (navigator.mediaDevices.getUserMedia = function (t) {\n            var e = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\n            return e ? new Promise(function (n, i) {\n              e.call(navigator, t, n, i);\n            }) : Promise.reject(new Error(\"浏览器不支持 getUserMedia !\"));\n          });\n        }, t.prototype.transformIntoPCM = function (t, e) {\n          var n = new Float32Array(t),\n            o = new Float32Array(e),\n            r = i.compress({\n              left: n,\n              right: o\n            }, this.inputSampleRate, this.outputSampleRate);\n          return i.encodePCM(r, this.oututSampleBits, this.littleEdian);\n        }, t.getPermission = function () {\n          return this.initUserMedia(), navigator.mediaDevices.getUserMedia({\n            audio: !0\n          }).then(function (t) {\n            t && t.getTracks().forEach(function (t) {\n              return t.stop();\n            });\n          });\n        }, t;\n      }();\n    e.default = o;\n  }]).default;\n});","map":{"version":3,"names":["t","e","exports","module","define","amd","Recorder","n","i","o","l","call","m","c","d","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","__esModule","create","bind","default","prototype","hasOwnProperty","p","s","length","setUint8","charCodeAt","compress","Math","max","left","a","right","floor","u","Float32Array","f","encodePCM","ArrayBuffer","DataView","min","setInt8","setInt16","encodeWAV","byteLength","setUint32","setUint16","getUint8","__extends","setPrototypeOf","__proto__","Array","constructor","isrecording","ispause","isplaying","setOption","setNewOption","start","Promise","reject","startRecord","pause","pauseRecord","resume","resumeRecord","stop","stopRecord","play","onplay","addPlayEnd","onplayend","getWAV","buffer","getPlayTime","pausePlay","onpauseplay","resumePlay","onresumeplay","stopPlay","onstopplay","destroy","destroyPlay","destroyRecord","getRecordAnalyseData","getAnalyseData","getPlayAnalyseData","getPCM","getData","inputSampleRate","outputSampleRate","oututSampleBits","littleEdian","getPCMBlob","Blob","downloadPCM","config","numChannels","getWAVBlob","type","downloadWAV","download","getChannelData","sampleBits","getInt16","getInt8","document","createElement","href","window","URL","createObjectURL","click","endplayFn","decodeAudioData","slice","createBufferSource","onended","currentTime","connect","destination","throwError","h","y","AudioContext","webkitAudioContext","createAnalyser","fftSize","Uint8Array","frequencyBinCount","getByteTimeDomainData","fn","Error","size","lBuffer","rBuffer","tempPCM","inputSampleBits","fileSize","duration","needRecord","sampleRate","Int16Array","initUserMedia","indexOf","context","initRecorder","navigator","mediaDevices","getUserMedia","audio","then","audioInput","createMediaStreamSource","stream","analyser","recorder","disconnect","source","clearRecordStatus","stopStream","closeAudioContext","flat","PCM","set","createScriptProcessor","createJavaScriptNode","apply","onaudioprocess","inputBuffer","push","onprocess","onprogress","vol","getTracks","forEach","close","state","webkitGetUserMedia","mozGetUserMedia","transformIntoPCM","getPermission"],"sources":["webpack://[name]/webpack/universalModuleDefinition","webpack://[name]/webpack/bootstrap","webpack://[name]/src/transform/transform.ts","webpack://[name]/src/index.ts","webpack://[name]/src/download/download.ts","webpack://[name]/src/player/player.ts","webpack://[name]/src/exception/exception.ts","webpack://[name]/src/recorder/recorder.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Recorder\"] = factory();\n\telse\n\t\troot[\"Recorder\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n","interface dataview {\r\n    byteLength: number,\r\n    buffer: {\r\n        byteLength: number,\r\n    },\r\n    getUint8: any,\r\n}\r\n\r\n/**\r\n * 在data中的offset位置开始写入str字符串\r\n * @param {TypedArrays} data    二进制数据\r\n * @param {Number}      offset  偏移量\r\n * @param {String}      str     字符串\r\n */\r\nfunction writeString(data, offset, str): void {\r\n    for (let i = 0; i < str.length; i++) {\r\n        data.setUint8(offset + i, str.charCodeAt(i));\r\n    }\r\n}\r\n\r\n/**\r\n * 数据合并压缩\r\n * 根据输入和输出的采样率压缩数据，\r\n * 比如输入的采样率是48k的，我们需要的是（输出）的是16k的，由于48k与16k是3倍关系，\r\n * 所以输入数据中每隔3取1位\r\n *\r\n * @param {float32array} data       [-1, 1]的pcm数据\r\n * @param {number} inputSampleRate  输入采样率\r\n * @param {number} outputSampleRate 输出采样率\r\n * @returns  {float32array}         压缩处理后的二进制数据\r\n */\r\nexport function compress(data, inputSampleRate: number, outputSampleRate: number) {\r\n    // 压缩，根据采样率进行压缩\r\n    let rate = inputSampleRate / outputSampleRate,\r\n        compression = Math.max(rate, 1),\r\n        lData = data.left,\r\n        rData = data.right,\r\n        length = Math.floor(( lData.length + rData.length ) / rate),\r\n        result = new Float32Array(length),\r\n        index = 0,\r\n        j = 0;\r\n\r\n    // 循环间隔 compression 位取一位数据\r\n    while (index < length) {\r\n        // 取整是因为存在比例compression不是整数的情况\r\n        let temp = Math.floor(j);\r\n\r\n        result[index] = lData[temp];\r\n        index++;\r\n\r\n        if (rData.length) {\r\n            /*\r\n            * 双声道处理\r\n            * e.inputBuffer.getChannelData(0)得到了左声道4096个样本数据，1是右声道的数据，\r\n            * 此处需要组和成LRLRLR这种格式，才能正常播放，所以要处理下\r\n            */\r\n            result[index] = rData[temp];\r\n            index++;\r\n        }\r\n\r\n        j += compression;\r\n    }\r\n    // 返回压缩后的一维数据\r\n    return result;\r\n}\r\n\r\n/**\r\n * 转换到我们需要的对应格式的编码\r\n *\r\n * @param {float32array} bytes      pcm二进制数据\r\n * @param {number}  sampleBits      采样位数\r\n * @param {boolean} littleEdian     是否是小端字节序\r\n * @returns {dataview}              pcm二进制数据\r\n */\r\nexport function encodePCM(bytes, sampleBits: number, littleEdian: boolean = true) {\r\n    let offset = 0,\r\n        dataLength = bytes.length * (sampleBits / 8),\r\n        buffer = new ArrayBuffer(dataLength),\r\n        data = new DataView(buffer);\r\n\r\n    // 写入采样数据\r\n    if (sampleBits === 8) {\r\n        for (let i = 0; i < bytes.length; i++, offset++) {\r\n            // 范围[-1, 1]\r\n            let s = Math.max(-1, Math.min(1, bytes[i]));\r\n            // 8位采样位划分成2^8=256份，它的范围是0-255;\r\n            // 对于8位的话，负数*128，正数*127，然后整体向上平移128(+128)，即可得到[0,255]范围的数据。\r\n            let val = s < 0 ? s * 128 : s * 127;\r\n            val = +val + 128;\r\n            data.setInt8(offset, val);\r\n        }\r\n    } else {\r\n        for (let i = 0; i < bytes.length; i++, offset += 2) {\r\n            let s = Math.max(-1, Math.min(1, bytes[i]));\r\n            // 16位的划分的是2^16=65536份，范围是-32768到32767\r\n            // 因为我们收集的数据范围在[-1,1]，那么你想转换成16位的话，只需要对负数*32768,对正数*32767,即可得到范围在[-32768,32767]的数据。\r\n            data.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, littleEdian);\r\n        }\r\n    }\r\n\r\n    return data;\r\n}\r\n\r\n/**\r\n * 编码wav，一般wav格式是在pcm文件前增加44个字节的文件头，\r\n * 所以，此处只需要在pcm数据前增加下就行了。\r\n *\r\n * @param {DataView} bytes           pcm二进制数据\r\n * @param {number}  inputSampleRate  输入采样率\r\n * @param {number}  outputSampleRate 输出采样率\r\n * @param {number}  numChannels      声道数\r\n * @param {number}  oututSampleBits  输出采样位数\r\n * @param {boolean} littleEdian      是否是小端字节序\r\n * @returns {DataView}               wav二进制数据\r\n */\r\nexport function encodeWAV(bytes: dataview, inputSampleRate: number, outputSampleRate: number, numChannels: number, oututSampleBits: number, littleEdian: boolean = true) {\r\n    let sampleRate = outputSampleRate > inputSampleRate ? inputSampleRate : outputSampleRate,   // 输出采样率较大时，仍使用输入的值，\r\n        sampleBits = oututSampleBits,\r\n        buffer = new ArrayBuffer(44 + bytes.byteLength),\r\n        data = new DataView(buffer),\r\n        channelCount = numChannels, // 声道\r\n        offset = 0;\r\n\r\n    // 资源交换文件标识符\r\n    writeString(data, offset, 'RIFF'); offset += 4;\r\n    // 下个地址开始到文件尾总字节数,即文件大小-8\r\n    data.setUint32(offset, 36 + bytes.byteLength, littleEdian); offset += 4;\r\n    // WAV文件标志\r\n    writeString(data, offset, 'WAVE'); offset += 4;\r\n    // 波形格式标志\r\n    writeString(data, offset, 'fmt '); offset += 4;\r\n    // 过滤字节,一般为 0x10 = 16\r\n    data.setUint32(offset, 16, littleEdian); offset += 4;\r\n    // 格式类别 (PCM形式采样数据)\r\n    data.setUint16(offset, 1, littleEdian); offset += 2;\r\n    // 声道数\r\n    data.setUint16(offset, channelCount, littleEdian); offset += 2;\r\n    // 采样率,每秒样本数,表示每个通道的播放速度\r\n    data.setUint32(offset, sampleRate, littleEdian); offset += 4;\r\n    // 波形数据传输率 (每秒平均字节数) 声道数 × 采样频率 × 采样位数 / 8\r\n    data.setUint32(offset, channelCount * sampleRate * (sampleBits / 8), littleEdian); offset += 4;\r\n    // 快数据调整数 采样一次占用字节数 声道数 × 采样位数 / 8\r\n    data.setUint16(offset, channelCount * (sampleBits / 8), littleEdian); offset += 2;\r\n    // 采样位数\r\n    data.setUint16(offset, sampleBits, littleEdian); offset += 2;\r\n    // 数据标识符\r\n    writeString(data, offset, 'data'); offset += 4;\r\n    // 采样数据总数,即数据总大小-44\r\n    data.setUint32(offset, bytes.byteLength, littleEdian); offset += 4;\r\n\r\n    // 给wav头增加pcm体\r\n    for (let i = 0; i < bytes.byteLength;) {\r\n        data.setUint8(offset, bytes.getUint8(i));\r\n        offset++;\r\n        i++;\r\n    }\r\n\r\n    return data;\r\n}\r\n","import { downloadPCM, downloadWAV, download } from './download/download';\r\nimport { compress, encodePCM, encodeWAV } from './transform/transform';\r\nimport Player from './player/player';\r\nimport Recorder from './recorder/recorder';\r\n\r\ndeclare let window: any;\r\ndeclare let Math: any;\r\ndeclare let navigator: any;\r\ndeclare let Promise: any;\r\n\r\n// 构造函数参数格式\r\ninterface recorderConfig {\r\n    sampleBits?: number,        // 采样位数\r\n    sampleRate?: number,        // 采样率\r\n    numChannels?: number,       // 声道数\r\n    compiling?: boolean,        // 是否边录边播\r\n}\r\n\r\nclass Index extends Recorder {\r\n    private isrecording: boolean = false;       // 是否正在录音\r\n    private ispause: boolean = false;           // 是否是暂停\r\n    private isplaying: boolean = false;         // 是否正在播放\r\n\r\n    public onplay: () => void;                  // 音频播放回调\r\n    public onpauseplay: () => void;             // 音频暂停回调\r\n    public onresumeplay: () => void;            // 音频恢复播放回调\r\n    public onstopplay: () => void;              // 音频停止播放回调\r\n    public onplayend: () => void;               // 音频正常播放结束\r\n    /**\r\n     * @param {Object} options 包含以下三个参数：\r\n     * sampleBits，采样位数，一般8,16，默认16\r\n     * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n     * numChannels，声道，1或2\r\n     */\r\n    constructor(options: recorderConfig = {}) {\r\n        super(options);\r\n    }\r\n\r\n    /**\r\n     * 重新修改配置\r\n     *\r\n     * @param {recorderConfig} [options={}]\r\n     * @memberof Recorder\r\n     */\r\n    public setOption(options: recorderConfig = {}) {\r\n        this.setNewOption(options);\r\n    }\r\n\r\n    /**\r\n     * Start the recording\r\n     */\r\n    start(): Promise<{}> {\r\n        if (this.isrecording) {\r\n            // 正在录音，则不允许\r\n            return Promise.reject();\r\n        }\r\n\r\n        this.isrecording = true;\r\n\r\n        return this.startRecord();\r\n    }\r\n\r\n    /**\r\n     * Pause the recording\r\n     */\r\n    pause(): void {\r\n        if (this.isrecording && !this.ispause) {\r\n            this.ispause = true;\r\n            // 当前不暂停的时候才可以暂停\r\n            this.pauseRecord();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 继续录音\r\n     */\r\n    resume(): void {\r\n        if (this.isrecording && this.ispause) {\r\n            this.ispause = false;\r\n            this.resumeRecord();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 停止录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    stop(): void {\r\n        if (this.isrecording) {\r\n            this.isrecording = false;\r\n            this.ispause = false;\r\n            this.stopRecord();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 播放录音\r\n     */\r\n    play(): void {\r\n        this.stop();\r\n        // 关闭前一次音频播放\r\n        this.isplaying = true;\r\n\r\n        this.onplay && this.onplay();\r\n        Player.addPlayEnd(this.onplayend);  // 注册播放完成后的回调事件\r\n\r\n        const dataV = this.getWAV();\r\n\r\n        if (dataV.byteLength > 44) {\r\n            Player.play(dataV.buffer);  // 播放\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取已经播放了多长时间\r\n     */\r\n    getPlayTime(): number {\r\n        return Player.getPlayTime();\r\n    }\r\n\r\n    /**\r\n     * 暂停播放录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    pausePlay(): void {\r\n        if (this.isrecording || !this.isplaying) {\r\n            // 正在录音或没有播放，暂停无效\r\n            return;\r\n        }\r\n\r\n        this.isplaying = false;\r\n        this.onpauseplay && this.onpauseplay();\r\n        Player.pausePlay();\r\n    }\r\n\r\n    /**\r\n     * 恢复播放录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    resumePlay(): void {\r\n        if (this.isrecording || this.isplaying) {\r\n            // 正在录音或已经播放或没开始播放，恢复无效\r\n            return;\r\n        }\r\n\r\n        this.isplaying = true;\r\n        this.onresumeplay && this.onresumeplay();\r\n        Player.resumePlay();\r\n    }\r\n\r\n    /**\r\n     * 停止播放\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    stopPlay(): void {\r\n        if (this.isrecording) {\r\n            // 正在录音，停止录音播放无效\r\n            return;\r\n        }\r\n\r\n        this.isplaying = false;\r\n        this.onstopplay && this.onstopplay();\r\n        Player.stopPlay();\r\n    }\r\n\r\n    destroy(): Promise<{}> {\r\n        Player.destroyPlay();\r\n\r\n        return this.destroyRecord();\r\n    }\r\n\r\n    /**\r\n     * 获取当前已经录音的PCM音频数据\r\n     *\r\n     * @returns[DataView]\r\n     * @memberof Recorder\r\n     */\r\n    // getWholeData() {\r\n    //     return this.tempPCM;\r\n    // }\r\n\r\n    /**\r\n     * 获取余下的新数据，不包括 getNextData 前一次获取的数据\r\n     *\r\n     * @returns [DataView]\r\n     * @memberof Recorder\r\n     */\r\n    // getNextData() {\r\n    //     let length = this.tempPCM.length,\r\n    //         data = this.tempPCM.slice(this.offset);\r\n\r\n    //     this.offset = length;\r\n\r\n    //     return data;\r\n    // }\r\n\r\n    /**\r\n     * 获取当前录音的波形数据，\r\n     * 调取频率由外部控制。\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    getRecordAnalyseData(): any {\r\n        return this.getAnalyseData();\r\n    }\r\n\r\n    /**\r\n     * 获取录音播放时的波形数据，\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    getPlayAnalyseData(): any {\r\n        // 现在录音和播放不允许同时进行，所有复用的录音的analyser节点。\r\n        return Player.getAnalyseData();\r\n    }\r\n\r\n    getPCM(): any {\r\n        // 先停止\r\n        this.stop();\r\n        // 获取pcm数据\r\n        let data: any = this.getData();\r\n        // 根据输入输出比例 压缩或扩展\r\n        data = compress(data, this.inputSampleRate, this.outputSampleRate);\r\n        // 按采样位数重新编码\r\n        return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n    }\r\n\r\n    /**\r\n     * 获取PCM格式的blob数据\r\n     *\r\n     * @returns { blob }  PCM格式的blob数据\r\n     * @memberof Recorder\r\n     */\r\n    getPCMBlob(): any {\r\n        return new Blob([ this.getPCM() ]);\r\n    }\r\n\r\n    /**\r\n     * 下载录音pcm数据\r\n     *\r\n     * @param {string} [name='recorder']    重命名的名字\r\n     * @memberof Recorder\r\n     */\r\n    downloadPCM(name: string = 'recorder'): void {\r\n        let pcmBlob = this.getPCMBlob();\r\n\r\n        downloadPCM(pcmBlob, name);\r\n    }\r\n\r\n    /**\r\n     * 获取WAV编码的二进制数据(dataview)\r\n     *\r\n     * @returns {dataview}  WAV编码的二进制数据\r\n     * @memberof Recorder\r\n     */\r\n    getWAV(): any {\r\n        let pcmTemp = this.getPCM();\r\n\r\n        // PCM增加44字节的头就是WAV格式了\r\n        return encodeWAV(pcmTemp, this.inputSampleRate,\r\n            this.outputSampleRate, this.config.numChannels, this.oututSampleBits, this.littleEdian);;\r\n    }\r\n\r\n    /**\r\n     * 获取WAV音频的blob数据\r\n     *\r\n     * @returns { blob }    wav格式blob数据\r\n     * @memberof Recorder\r\n     */\r\n    getWAVBlob(): any {\r\n        return new Blob([ this.getWAV() ], { type: 'audio/wav' });\r\n    }\r\n\r\n    /**\r\n     * 下载录音的wav数据\r\n     *\r\n     * @param {string} [name='recorder']    重命名的名字\r\n     * @memberof Recorder\r\n     */\r\n    downloadWAV(name: string = 'recorder'): void {\r\n        let wavBlob = this.getWAVBlob();\r\n\r\n        downloadWAV(wavBlob, name);\r\n    }\r\n\r\n    /**\r\n     * 通用的下载接口\r\n     */\r\n    download(blob, name: string, type: string): void {\r\n        download(blob, name, type);\r\n    }\r\n\r\n    /**\r\n     * 获取左和右声道的数据\r\n     *\r\n     * @returns [DataView]\r\n     */\r\n    getChannelData(): any {\r\n        const all = this.getPCM();\r\n        const length = all.byteLength;\r\n        const littleEdian = this.littleEdian\r\n        const res = { left: null, right: null }\r\n\r\n        if (this.config.numChannels === 2) {\r\n            // 双通道,劈开\r\n            const lD = new DataView(new ArrayBuffer(length / 2))\r\n            const rD = new DataView(new ArrayBuffer(length / 2))\r\n            // 双声道，需要拆分下数据\r\n\r\n            if (this.config.sampleBits === 16) {\r\n                for (var i = 0; i < length / 2; i += 2) {\r\n                    lD.setInt16(i, all.getInt16(i * 2, littleEdian), littleEdian)\r\n                    rD.setInt16(i, all.getInt16(i * 2 + 2, littleEdian), littleEdian)\r\n                }\r\n            } else {\r\n                for (var i = 0; i < length / 2; i += 2) {\r\n                    lD.setInt8(i, all.getInt8(i * 2))\r\n                    rD.setInt8(i, all.getInt8(i * 2 + 1))\r\n                }\r\n            }\r\n\r\n            res.left = lD\r\n            res.right = rD\r\n        } else {\r\n            // 单通道\r\n            res.left = all\r\n        }\r\n\r\n        return res\r\n    }\r\n}\r\n\r\nexport default Index;\r\n","/**\r\n * 下载录音文件\r\n * @private\r\n * @param {*} blob      blob数据\r\n * @param {string} name 下载的文件名\r\n * @param {string} type 下载的文件后缀\r\n */\r\nfunction _download(blob, name: string, type: string): void {\r\n    let oA = document.createElement('a');\r\n\r\n    oA.href = window.URL.createObjectURL(blob);\r\n    oA.download = `${ name }.${ type }`;\r\n    oA.click();\r\n}\r\n\r\n/**\r\n * 下载录音的wav数据\r\n *\r\n * @param {blob}   需要下载的blob数据类型\r\n * @param {string} [name='recorder']    重命名的名字\r\n */\r\nexport function downloadWAV(wavblob, name: string = 'recorder'): void {\r\n    _download(wavblob, name, 'wav');\r\n}\r\n\r\n/**\r\n * 下载录音pcm数据\r\n *\r\n * @param {blob}   需要下载的blob数据类型\r\n * @param {string} [name='recorder']    重命名的名字\r\n * @memberof Recorder\r\n */\r\nexport function downloadPCM(pcmBlob, name: string = 'recorder'): void {\r\n    _download(pcmBlob, name, 'pcm');\r\n}\r\n\r\n// 通用下载接口\r\nexport function download(blob, name: string, type: string) {\r\n    return _download(blob, name, type)\r\n}\r\n","import { throwError } from '../exception/exception'\r\n\r\ndeclare let window: any;\r\n\r\nlet source: any = null;\r\nlet playTime: number = 0;       // 相对时间，记录暂停位置\r\nlet playStamp: number = 0;      // 开始或暂停后开始的时间戳(绝对)\r\nlet context: any = null;\r\nlet analyser: any = null;\r\n\r\nlet audioData: any = null;\r\n// let hasInit: boolean = false;           // 是否已经初始化了\r\nlet isPaused: boolean = false;\r\nlet totalTime: number = 0;\r\nlet endplayFn: any = function() {};\r\n\r\n/**\r\n * 初始化\r\n */\r\nfunction init(): void {\r\n    context = new (window.AudioContext || window.webkitAudioContext)();\r\n    analyser = context.createAnalyser();\r\n    analyser.fftSize = 2048;                   // 表示存储频域的大小\r\n}\r\n\r\n/**\r\n * play\r\n * @returns {Promise<{}>}\r\n */\r\nfunction playAudio(): Promise<{}> {\r\n    isPaused = false;\r\n\r\n    return context.decodeAudioData(audioData.slice(0), buffer => {\r\n        source = context.createBufferSource();\r\n\r\n        // 播放结束的事件绑定\r\n        source.onended = () => {\r\n            if (!isPaused) {  // 暂停的时候也会触发该事件\r\n                // 计算音频总时长\r\n                totalTime = context.currentTime - playStamp + playTime;\r\n                endplayFn();\r\n            }\r\n\r\n        }\r\n\r\n        // 设置数据\r\n        source.buffer = buffer;\r\n        // connect到分析器，还是用录音的，因为播放时不能录音的\r\n        source.connect(analyser);\r\n        analyser.connect(context.destination);\r\n        source.start(0, playTime);\r\n\r\n        // 记录当前的时间戳，以备暂停时使用\r\n        playStamp = context.currentTime;\r\n    }, function(e) {\r\n        throwError(e);\r\n    });\r\n}\r\n\r\n// 销毁source, 由于 decodeAudioData 产生的source每次停止后就不能使用，所以暂停也意味着销毁，下次需重新启动。\r\nfunction destroySource() {\r\n    if (source) {\r\n        source.stop();\r\n        source = null;\r\n    }\r\n}\r\n\r\nexport default class Player {\r\n    /**\r\n     * play record\r\n     * @static\r\n     * @param {ArrayBuffer} arraybuffer\r\n     * @memberof Player\r\n     */\r\n    static play(arraybuffer): Promise<{}> {\r\n        if (!context) {\r\n            // 第一次播放要初始化\r\n            init();\r\n        }\r\n        this.stopPlay();\r\n        // 缓存播放数据\r\n        audioData = arraybuffer;\r\n        totalTime = 0;\r\n\r\n        return playAudio();\r\n    }\r\n\r\n    /**\r\n     * 暂停播放录音\r\n     * @memberof Player\r\n     */\r\n    static pausePlay(): void {\r\n        destroySource();\r\n        // 多次暂停需要累加\r\n        playTime += context.currentTime - playStamp;\r\n        isPaused = true;\r\n    }\r\n\r\n    /**\r\n     * 恢复播放录音\r\n     * @memberof Player\r\n     */\r\n    static resumePlay(): Promise<{}> {\r\n        return playAudio();\r\n    }\r\n\r\n    /**\r\n     * 停止播放\r\n     * @memberof Player\r\n     */\r\n    static stopPlay() {\r\n        playTime = 0;\r\n        audioData = null;\r\n\r\n        destroySource();\r\n    }\r\n\r\n    static destroyPlay() {\r\n        this.stopPlay();\r\n    }\r\n\r\n    static getAnalyseData() {\r\n        let dataArray = new Uint8Array(analyser.frequencyBinCount);\r\n        // 将数据拷贝到dataArray中。\r\n        analyser.getByteTimeDomainData(dataArray);\r\n\r\n        return dataArray;\r\n    }\r\n\r\n    /**\r\n     * 增加录音播放完成的事件绑定\r\n     *\r\n     * @static\r\n     * @param {*} [fn=function() {}]\r\n     * @memberof Player\r\n     */\r\n    static addPlayEnd(fn: any = function() {}) {\r\n        endplayFn = fn;\r\n    }\r\n\r\n    // 获取已经播放的时长\r\n    static getPlayTime(): number {\r\n        let pTime = isPaused ? playTime : context.currentTime - playStamp + playTime;\r\n\r\n        return totalTime || pTime;\r\n    }\r\n}\r\n","/**\r\n * 异常处理\r\n * @static\r\n * @param {*} message   错误消息\r\n */\r\nexport function throwError(message: string) {\r\n    throw new Error(message);\r\n}\r\n","import { compress, encodePCM, encodeWAV } from '../transform/transform';\r\n\r\ndeclare let window: any;\r\ndeclare let Math: any;\r\ndeclare let navigator: any;\r\ndeclare let Promise: any;\r\n\r\n// 构造函数参数格式\r\ninterface recorderConfig {\r\n    sampleBits?: number,        // 采样位数\r\n    sampleRate?: number,        // 采样率\r\n    numChannels?: number,       // 声道数\r\n    compiling?: boolean,        // 是否边录边播\r\n}\r\n\r\nexport default class Recorder {\r\n    private context: any;\r\n    protected config: recorderConfig;               // 配置\r\n    private analyser: any;\r\n    private size: number = 0;                       // 录音文件总长度\r\n    private lBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(左声道)\r\n    private rBuffer: Array<Float32Array> = [];      // pcm音频数据搜集器(右声道)\r\n    private PCM: any;                               // 最终的PCM数据缓存，避免多次encode\r\n    private tempPCM: Array<DataView> = [];          // 边录边转时临时存放pcm的\r\n    private audioInput: any;\r\n    protected inputSampleRate: number;              // 输入采样率\r\n    protected inputSampleBits: number = 16;         // 输入采样位数\r\n    protected outputSampleRate: number;             // 输出采样率\r\n    protected oututSampleBits: number;              // 输出采样位数\r\n    private source: any;                            // 音频输入\r\n    private recorder: any;\r\n    private stream: any;                            // 流\r\n    protected littleEdian: boolean;                 // 是否是小端字节序\r\n    protected fileSize: number = 0;                 // 录音大小，byte为单位\r\n    protected duration: number = 0;                 // 录音时长\r\n    private needRecord: boolean = true;             // 由于safari问题，导致使用该方案代替disconnect/connect方案\r\n    // 正在录音时间，参数是已经录了多少时间了\r\n    public onprocess: (duration: number) => void;\r\n    // onprocess 替代函数，保持原来的 onprocess 向下兼容\r\n    public onprogress: (payload: {\r\n        duration: number,\r\n        fileSize: number,\r\n        vol: number,\r\n        // data: Array<DataView>,      // 当前存储的所有录音数据\r\n    }) => void;\r\n    public onplay: () => void;                  // 音频播放回调\r\n    public onpauseplay: () => void;             // 音频暂停回调\r\n    public onresumeplay: () => void;            // 音频恢复播放回调\r\n    public onstopplay: () => void;              // 音频停止播放回调\r\n    public onplayend: () => void;               // 音频正常播放结束\r\n\r\n    /**\r\n     * @param {Object} options 包含以下三个参数：\r\n     * sampleBits，采样位数，一般8,16，默认16\r\n     * sampleRate，采样率，一般 11025、16000、22050、24000、44100、48000，默认为浏览器自带的采样率\r\n     * numChannels，声道，1或2\r\n     */\r\n    constructor(options: recorderConfig = {}) {\r\n        // 临时audioContext，为了获取输入采样率的\r\n        let context = new (window.AudioContext || window.webkitAudioContext)();\r\n\r\n        this.inputSampleRate = context.sampleRate;     // 获取当前输入的采样率\r\n\r\n        // 设置输出配置\r\n        this.setNewOption(options);\r\n\r\n        // 判断端字节序\r\n        this.littleEdian = (function() {\r\n            let buffer = new ArrayBuffer(2);\r\n            new DataView(buffer).setInt16(0, 256, true);\r\n            return new Int16Array(buffer)[0] === 256;\r\n        })();\r\n        // 兼容 getUserMedia\r\n        Recorder.initUserMedia();\r\n    }\r\n\r\n    protected setNewOption(options: recorderConfig = {}) {\r\n        this.config = {\r\n            // 采样数位 8, 16\r\n            sampleBits: ~[8, 16].indexOf(options.sampleBits) ? options.sampleBits : 16,\r\n            // 采样率\r\n            sampleRate: ~[8000, 11025, 16000, 22050, 24000, 44100, 48000].indexOf(options.sampleRate) ? options.sampleRate : this.inputSampleRate,\r\n            // 声道数，1或2\r\n            numChannels: ~[1, 2].indexOf(options.numChannels) ? options.numChannels : 1,\r\n            // 是否需要边录边转，默认关闭，后期使用web worker\r\n            // compiling: !!options.compiling || false,   // 先移除\r\n        };\r\n        // 设置采样的参数\r\n        this.outputSampleRate = this.config.sampleRate;     // 输出采样率\r\n        this.oututSampleBits = this.config.sampleBits;      // 输出采样数位 8, 16\r\n    }\r\n\r\n    /**\r\n     * 开始录音\r\n     *\r\n     * @returns {Promise<{}>}\r\n     * @memberof Recorder\r\n     */\r\n    startRecord(): Promise<{}> {\r\n        if (this.context) {\r\n            // 关闭先前的录音实例，因为前次的实例会缓存少量前次的录音数据\r\n            this.destroyRecord();\r\n        }\r\n        // 初始化\r\n        this.initRecorder();\r\n\r\n        return navigator.mediaDevices.getUserMedia({\r\n            audio: true\r\n        }).then(stream => {\r\n            // audioInput表示音频源节点\r\n            // stream是通过navigator.getUserMedia获取的外部（如麦克风）stream音频输出，对于这就是输入\r\n            this.audioInput = this.context.createMediaStreamSource(stream);\r\n            this.stream = stream;\r\n        }/* 报错丢给外部使用者catch，后期可在此处增加建议性提示\r\n            , error => {\r\n            // 抛出异常\r\n            Recorder.throwError(error.name + \" : \" + error.message);\r\n        } */).then(() => {\r\n            // audioInput 为声音源，连接到处理节点 recorder\r\n            this.audioInput.connect(this.analyser);\r\n            this.analyser.connect(this.recorder);\r\n            // this.audioInput.connect(this.recorder);\r\n            // 处理节点 recorder 连接到扬声器\r\n            this.recorder.connect(this.context.destination);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 暂停录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    pauseRecord(): void {\r\n        this.needRecord = false;\r\n    }\r\n\r\n    /**\r\n     * 继续录音\r\n     *\r\n     * @memberof Recorder\r\n     */\r\n    resumeRecord(): void {\r\n        this.needRecord = true;\r\n    }\r\n\r\n    /**\r\n     * 停止录音\r\n     *\r\n     */\r\n    stopRecord(): void {\r\n        this.audioInput && this.audioInput.disconnect();\r\n        this.source && this.source.stop();\r\n        this.recorder.disconnect();\r\n        this.analyser.disconnect();\r\n        this.needRecord = true;\r\n    }\r\n\r\n    /**\r\n     * 销毁录音对象\r\n     *\r\n     */\r\n    destroyRecord(): Promise<{}> {\r\n        this.clearRecordStatus();\r\n        // 结束流\r\n        this.stopStream();\r\n\r\n        return this.closeAudioContext();\r\n    }\r\n\r\n    getAnalyseData() {\r\n        let dataArray = new Uint8Array(this.analyser.frequencyBinCount);\r\n        // 将数据拷贝到dataArray中。\r\n        this.analyser.getByteTimeDomainData(dataArray);\r\n\r\n        return dataArray;\r\n    }\r\n\r\n    // 获取录音数据\r\n    getData() {\r\n        let data: any = this.flat();\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * 清除状态\r\n     *\r\n     */\r\n    private clearRecordStatus() {\r\n        this.lBuffer.length = 0;\r\n        this.rBuffer.length = 0;\r\n        this.size = 0;\r\n        this.fileSize = 0;\r\n        this.PCM = null;\r\n        this.audioInput = null;\r\n        this.duration = 0;\r\n    }\r\n\r\n    /**\r\n     * 将二维数组转一维\r\n     *\r\n     * @private\r\n     * @returns  {float32array}     音频pcm二进制数据\r\n     * @memberof Recorder\r\n     */\r\n    private flat() {\r\n        let lData = null,\r\n            rData = new Float32Array(0);    // 右声道默认为0\r\n\r\n        // 创建存放数据的容器\r\n        if (1 === this.config.numChannels) {\r\n            lData = new Float32Array(this.size);\r\n        } else {\r\n            lData = new Float32Array(this.size / 2);\r\n            rData = new Float32Array(this.size / 2);\r\n        }\r\n        // 合并\r\n        let offset = 0; // 偏移量计算\r\n\r\n        // 将二维数据，转成一维数据\r\n        // 左声道\r\n        for (let i = 0; i < this.lBuffer.length; i++) {\r\n            lData.set(this.lBuffer[i], offset);\r\n            offset += this.lBuffer[i].length;\r\n        }\r\n\r\n        offset = 0;\r\n        // 右声道\r\n        for (let i = 0; i < this.rBuffer.length; i++) {\r\n            rData.set(this.rBuffer[i], offset);\r\n            offset += this.rBuffer[i].length;\r\n        }\r\n\r\n        return {\r\n            left: lData,\r\n            right: rData\r\n        };\r\n    }\r\n\r\n    /**\r\n     * 初始化录音实例\r\n     */\r\n    private initRecorder(): void {\r\n        // 清空数据\r\n        this.clearRecordStatus();\r\n\r\n        this.context = new (window.AudioContext || window.webkitAudioContext)();\r\n\r\n        this.analyser = this.context.createAnalyser();  // 录音分析节点\r\n        this.analyser.fftSize = 2048;                   // 表示存储频域的大小\r\n\r\n        // 第一个参数表示收集采样的大小，采集完这么多后会触发 onaudioprocess 接口一次，该值一般为1024,2048,4096等，一般就设置为4096\r\n        // 第二，三个参数分别是输入的声道数和输出的声道数，保持一致即可。\r\n        let createScript = this.context.createScriptProcessor || this.context.createJavaScriptNode;\r\n        this.recorder = createScript.apply(this.context, [4096, this.config.numChannels, this.config.numChannels]);\r\n\r\n        // 音频采集\r\n        this.recorder.onaudioprocess = e => {\r\n            if (!this.needRecord) {\r\n                return;\r\n            }\r\n            // 左声道数据\r\n            // getChannelData返回Float32Array类型的pcm数据\r\n            let lData = e.inputBuffer.getChannelData(0),\r\n                rData = null,\r\n                vol = 0;        // 音量百分比\r\n\r\n            this.lBuffer.push(new Float32Array(lData));\r\n\r\n            this.size += lData.length;\r\n\r\n            // 判断是否有右声道数据\r\n            if (2 === this.config.numChannels) {\r\n                rData = e.inputBuffer.getChannelData(1);\r\n                this.rBuffer.push(new Float32Array(rData));\r\n\r\n                this.size += rData.length;\r\n            }\r\n\r\n            // 边录边转处理 暂时不支持\r\n            // if (this.config.compiling) {\r\n            //     let pcm = this.transformIntoPCM(lData, rData);\r\n\r\n            //     this.tempPCM.push(pcm);\r\n            //     // 计算录音大小\r\n            //     this.fileSize = pcm.byteLength * this.tempPCM.length;\r\n            // } else {\r\n                // 计算录音大小\r\n                this.fileSize = Math.floor(this.size / Math.max( this.inputSampleRate / this.outputSampleRate, 1))\r\n                    * (this.oututSampleBits / 8)\r\n            // }\r\n            // 为何此处计算大小需要分开计算。原因是先录后转时，是将所有数据一起处理，边录边转是单个 4096 处理，\r\n            // 有小数位的偏差。\r\n\r\n            // 计算音量百分比\r\n            vol = Math.max.apply(Math, lData) * 100;\r\n            // 统计录音时长\r\n            this.duration += 4096 / this.inputSampleRate;\r\n            // 录音时长回调\r\n            this.onprocess && this.onprocess(this.duration);\r\n            // 录音时长及响度回调\r\n            this.onprogress && this.onprogress({\r\n                duration: this.duration,\r\n                fileSize: this.fileSize,\r\n                vol,\r\n                // data: this.tempPCM,     // 当前所有的pcm数据，调用者控制增量\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 终止流（这可以让浏览器上正在录音的标志消失掉）\r\n     * @private\r\n     * @memberof Recorder\r\n     */\r\n    private stopStream() {\r\n        if (this.stream && this.stream.getTracks) {\r\n            this.stream.getTracks().forEach(track => track.stop());\r\n            this.stream = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * close兼容方案\r\n     * 如firefox 30 等低版本浏览器没有 close方法\r\n     */\r\n    private closeAudioContext() {\r\n        if (this.context && this.context.close && this.context.state !== 'closed') {\r\n            return this.context.close();\r\n        } else {\r\n            return new Promise((resolve) => {\r\n                resolve();\r\n            });\r\n        }\r\n    }\r\n\r\n    // getUserMedia 版本兼容\r\n    static initUserMedia() {\r\n        if (navigator.mediaDevices === undefined) {\r\n            navigator.mediaDevices = {};\r\n        }\r\n\r\n        if (navigator.mediaDevices.getUserMedia === undefined) {\r\n            navigator.mediaDevices.getUserMedia = function(constraints) {\r\n                let getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;\r\n\r\n                if (!getUserMedia) {\r\n                    return Promise.reject(new Error('浏览器不支持 getUserMedia !'));\r\n                }\r\n\r\n                return new Promise(function(resolve, reject) {\r\n                    getUserMedia.call(navigator, constraints, resolve, reject);\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 将获取到到左右声道的Float32Array数据编码转化\r\n     *\r\n     * @param {Float32Array} lData  左声道数据\r\n     * @param {Float32Array} rData  有声道数据\r\n     * @returns DataView\r\n     */\r\n    private transformIntoPCM(lData, rData) {\r\n        let lBuffer = new Float32Array(lData),\r\n            rBuffer = new Float32Array(rData);\r\n\r\n        let data = compress({\r\n            left: lBuffer,\r\n            right: rBuffer,\r\n        }, this.inputSampleRate, this.outputSampleRate);\r\n\r\n        return encodePCM(data, this.oututSampleBits, this.littleEdian);\r\n    }\r\n\r\n    static getPermission(): Promise<{}> {\r\n        this.initUserMedia();\r\n\r\n        return navigator.mediaDevices.getUserMedia({audio: true}).then((stream) => {\r\n            stream && stream.getTracks().forEach(track => track.stop());\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}